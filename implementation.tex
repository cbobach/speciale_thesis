The main idea of this chapter is to introduce the different stages during the implementation. Here I will introduce the different problems and the solutions I have chosen to overcome those problems.

\todo{Introduce different sections}

%%%%%%%%%%%%%%%%% CIRCUIT IMPLEMENTATION %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shuffle algorithm implementation}
\todo{Describe the implementation of the algorithms}
\todo{Describe problems}
\todo{Describe solutions}

\todo{Describe gadgets of the two shuffle protocols}

Becuse the $DUPLO$ protocol was chosen as the MPC protocol to use in the implementation the first hurdel was to make the circuits that should handle the shuffling of cards. Since circuits become rather complex when trying to implement simple functions it was important to have a compiler that could translate the algorithms into circuit representation. Luckly there was a compiler for generating $DUPLO$-circuits that could be used. Therefor before staring to implemt the shuffle algorithms I read up on the documentation for the compiler\footnote{Which can be found at github: \url{https://github.com/AarhusCrypto/DUPLO/tree/master/frigate}}. The documentation is from the first version of the $Frigate$ compiler which was extended to compile to the $DUPLO$ format. The documentation was not well specified and it was a long time since I last had worked with circuits in such a way. This resulted in some hard earned experience.

The most important and different things to take into account here is the possibility of wirre acces and only one level functions. First of all it is possible to specify which and how many wires should represent a value like $y=x{index:size}$. This is the way bit inputs is translated into higher level representations. When it comes to functions there are some restrictions. First of all only one level of functions is allowed. Second of all only assignments in the main method is allowed through function calls. Otherwise the programing language used resembles $C$.


%%%%%%%%%%%%%%%%%%% CIRCUIT GENERATION %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Circuit generation}
From chapter \ref{ch:shuffle} we know the different algorithms as algorithm \ref{fisher_yates_alg} and \ref{con_swap_alg}. These were implemented in a $wir$ format which resembles the $C$ programming style. To compile these $wir$ files to circuits I used the $Frigate$ compiler. I used a modified version of the original $Frigate$ compiler which was modified to be able to output $duplo$ circuit format. Both the compiler and the $wir$ language was not well documented and therefor a lot of testing and small corrections was required. During this time I got to know a lot about circuit generation and their representation. The circuits generated by the $Frigate$ compiler was tested with the evaluator of the $duplo$ MPC protocol. This gave me the possibility to evaluate the circuits implemented and see if they did what was expected of them. The $Conditional Swap$ algorithm was rather straight forward to implement when I understood the $wir$ syntax. When parsing it through the evaluator with different $seeds$ its seemed to produce correct results.

It was a complete other result when it came to the $Fisher\text{-}Yates$ algorithm. As described in chapter \ref{ch:shuffle} the algorithm goes through different rounds. I splitted the algorithm in to different stages when the result was not like expected. Such that I could investigate where the error was. The first stage was the $XOR$ stage where I did not find any problems. Then there was the second stag which was the stage where the $seeds$ is modulated out. This stage gave some strange results. The problem seemed to be the modulo operator $\%$. After many tests and different approaches where I could not get it to work I tried to use the old version of $Frigate$ to exclude that error could have been introduced in the modification process. But the output file from the old version of the compiler could not be read by the evaluator of $duplo$. Therefor I wrote a parser from the $Frigate$ circuit format to the $duplo$ format whiteout any optimizations. Just as straight forward and stupid as it could be. Then after testing the old compiler and the new parser on the test cases made that far I had a strong believe that the parser was correct. When using the old compiler and the parser on the modulo stage circuit it revealed that the old and new compiler did not produce the same result. This gave me the confirmation that something could be wrong with the new modified version of the circuit compiler. After further test it was clear that some of the gates the old compiler produced was not handled by the new compiler and therefor introduced errors in the circuit. This resulted in a correction of the new compiler which now adds support of all 16 different gates and $duplo$ was also updated to handle all 16 gate types. All in all the detection of this error resulted in a more thorough tested circuit compiler and a protocol that now handles all gate types. But it is still the case that the old compiler does not handle modulo for all cases. It handles the cases for powers of 2 correct but when doing modulo anything else is not sure to be correct. Therefor will the $Fisher\text{-}Yates$ algorithm not work correctly which is a shame but as stated earlier it is not secure in this setting.

\todo{Ni compiler, mod, error}
\todo{my paser, differences in ciruits -> updated compiler}
\todo{test, subciruits generated, parser to test compiler (Not all gates were implemented)}

\todo{Write abouth the Frigate compiler only supporting modulo to the power of 2, $2^n$ (Stille v1 problem)}

\todo{Technical comparison of the circuits, number of gates, XOR gates, NON-XOR gates (table)}

%%%%%%%%%%%%%%%% 2PC POKER IMPLEMENTATION %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Poker implementation}
\todo{Describe the roles of the two parties}
\todo{Describe the setting}

\todo{Describe the more interresting setting, why is it interresting and why is it not implemented}
