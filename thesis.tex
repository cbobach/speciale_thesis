\documentclass[twoside,11pt,openright]{report}
%
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{appendix}
\usepackage{a4}
\usepackage{caption}
\usepackage{cite}
\usepackage{color}
\usepackage{datetime}
\usepackage{epsfig}
\usepackage{epstopdf} 
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{latexsym}
\usepackage{lmodern}
\usepackage{multirow}
\usepackage{pstricks}
\usepackage{subcaption}
\usepackage{verbatim}
%
\usepackage[english]{babel}
\usepackage[labeled]{multibib}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%
\graphicspath{ {figurs/} }
% Usage: \todo{Document the TODO command.}
% Comment out second line to disable.
\newcommand{\todo}[1]{}
\renewcommand{\todo}[1]{{\color{red} TODO: {#1}} \\}
\renewcommand*\ttdefault{txtt}
%
\DeclareCaptionFormat{myformat}{#1#2#3\hrulefill}
\captionsetup[figure]{format=myformat}
\DeclareCaptionFormat{myformat1}{#1#2#3}
\captionsetup[subfigure]{format=myformat1}
\captionsetup[table]{format=myformat}
\captionsetup[subtable]{format=myformat1}
%
\newcites{A,B}{Primary Bibliography,Secondary Bibliography}
%
% see http://imf.au.dk/system/latex/bog/

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Secure Distributed Poker using MPC}\\[2ex]
{\huge\sf Christian Bobach, 20104256}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Master's Thesis, Computer Science\\[1ex] 
\monthname\ \the\year  \\[1ex] Advisor: Claudio Orlandi\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{plain}

%%%%%%%%%%%%%%%%%%%%%%%%% ABSTRACT %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Abstract}
\addcontentsline{toc}{chapter}{Abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%% RESUME %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Resum\'e}
\addcontentsline{toc}{chapter}{Resum\'e}

%%%%%%%%%%%%%%%%%%%%% ACKNOWLEDGMENTS %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Acknowledgments}
\addcontentsline{toc}{chapter}{Acknowledgments}

\vspace{2ex}
\begin{flushright}
  \emph{Christian Bobach,}\\
  \emph{Aarhus, \today.}
\end{flushright}

\tableofcontents
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{ch:intro}
In this thesis I have made a practical study of the application of a Multi Party Computation(MPC) protocol. To show what can be done by a MPC protocol and how it can be used a poker game has been developed as a proof of concept.

It is easy to think of how one could be cheated when playing an online game of poker. It is hard for me as a player to know if the dealer and one of the other players has an agrangement such that the dealer always deals better cards to that player such this player wins in the long run. The idea by using a MPC protocol here is to guarantee that the cards are dealt fairly. Such that the player of online poker can trust the protocol and know that the cards are guaranteed to be dealt fairly.

To ensure that the card are dealt fairly I will use a MPC protocol to take care of the shuffling of the cards. In this study I will use a two party computation(2PC) protocol called $DUPLO$ which will be introduced in chapter \ref{ch:duplo}. In this thesis a two party heads up poker game will be studied. The study is a showcase of the possibilities of MPC protocols and what can be achieved by them. It should be possible to easy extend the work done in this thesis to work in cases with more that only two parties using a another MPC protocol designed for that purpose. It should also be equaly easy to extend the game to work with more players.

\bigskip

For the inplemetation of poker I have studied various fields both in computer science and other fields. I have read up on different types of poker games to figure out which one was best suited for a two party setting. I have studied the underlying MPC protocol to understand how it works and to ensure that it for fills the right properties needed for an application as a poker game. I have studied different permutation algorithms and implemented them to compare them and see what effects they have on the underlying protocol.

\bigskip
\todo{introduce chapter on DUPLO}

\bigskip

\todo{introduce chapter on shuffle algorithms}
In chapter \ref{ch:shuffle} on shuffle algorithms I introduce the different algorithms studied during the project. I argue for the ideas behind the algorithm and why they work in the application of a poker game. Some optimizations that can be done to the algorithm to reduce their size are perposed. At last the algorithms will be compared on a teoretical level to see different benefits.

\bigskip

\todo{introduce chapter on Poker Implementation}

\bigskip

\todo{introduce chapter on conclusion and proposals of futher studies}

\bigskip

In the next section the variant of poker chosen for this study will be introduced and others will be mentioned to give an idea of their differences.

%%%%%%%%%%%%%%%%%%%%%%%%%%% POKER %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Poker Game}
\label{sec:poker}
A poker game is a card game played in various rounds where the player draw cards and place bets. The bets are won according to a predefined list where the card constellation with the lowest probability wins. There exists many different variants of poker but only one will be chosen. The variant chosen to use in this thesis is known as 'five card draw' poker. In this study the game will be played between two parties. In this variant of poker five cards are dealt to each player in the first round. After this the first betting round occurs. Then a swap round occurs where the players have the possibility to chose how many cards to change to try to improve their hand. Then a last betting round is performed before the cards is revealed and a winner is declared.

Five card draw poker is played with a deck of 52. This poses some requirements for our shuffling algorithms. Since there are 52 cards in the deck this yields $52!$ different permutations. We require a shuffle algorithm that can produce exact these permutations to represent all the possible shuffles of the card deck. Because only the first 20 card of the deck is needed per game it is enough for the algorithm to produce a complete shuffle of these card and not the remaining 32 cards. This implies that the algorithm used to shuffle the cards only needs to produce $$\frac{52!}{(52-20)!}$$ different permutations. Since each player is dealt five card and at most can chane all these cards in the swap round. This yealds 10 card per player and therefore 20 in total.

Other variants of poker require a different amount of cards per game. One example could be if the came included tree players instead of two, then 30 cards of the complete deck would be needed. An other example could be the Texas Hold'em variant which is played by dealing two cards to each player and placing tree cards face upwards on the table. These cards are the used as a part of each of the players hand. After this a betting round is performed. This is continued by another card dealt facing upwards on the table. This is done twice before the final revelation phase where the winner is found. If the game involves two players then 4 card is dealt to the players and 5 to the table resulting in a total of 9 cards used. This implies an algorithm producing $$\frac{52!}{(52-9)!}$$ different permutations of the card deck is needed. This is also known as an $m$ out of $n$ permutation.

From here on when talking about a poker game the five card draw poker will be the reference otherwise it will be specified. This is especially interesting when looking for optimizations on the shuffle algorithms which will be introduced in chapter \ref{ch:shuffle} and when they are compared. When coming to chapter \ref{ch:implementation} this will have effect when the cards are dealt. Both in terms of the amount of data sent and the time used by the protocol.


%%%%%%%%%%%%%%%%%%%%%%%%%%% DUPLO %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{DUPLO}
\label{ch:duplo}

In this chapter I will introduce the $DUPLO$ framework introduced in \citeA{duplo} and why this was chossen to handle the communication and security of the poker game. I will explain how the structure of the $DUPLO$ protocol works and describe what the different framework calls handle. I will go over the secury details of the protocol to illustrate how this is guaranteed. Lastly I will introduce the $Frigate$ compiler which is shiped whith the $DUPLO$ framework to generate circuits for the evaluation.

\bigskip

As it can be read in \citeA{duplo} the $DUPLO$ framework is among the latest papers where the effency of a two party computation(2PC) protocol using garbled circuit in a malicious setting is studdied. In the paper $DUPLO$ is claimed to reach the protocol performes better then any existing protocol. Their idea came from the fact that the two extreme variants of cut and chose protocols did not preform well in each end of the spectrum when it comes to the size of the circuits. As they cam up with a new approch to the way cut and chose 2PC protocols could be done in the malicious setting. The idea is to garble subcomponets of the circuit and get a optimum somwhare inbetween the two extremes; garbling of complete circuits or garbling on gate level, cut and chose. The aim was to show that the gate level cut and chose added an overhead when soldering these thogether again when the circuits for evaluation is build. At the same time to show when the number of subcomponents goes up there is a performance gain compared to whole gate cut and chose because of the amortized benefits. 

As seen in section 7 on performance in \citeA{duplo} it is clearly that the experiments done on real life circuits yealds an optimal cut and chose strategy which differs from the earlier known possibilities. The gain in terms of running time encreases as the size of the circuits get bigger. Which shows that the $DUPLO$ protocol scales signicicantly better that the rest.

\bigskip

As this is the best performing 2PC protocol at the moment combined with the fact that it is developed at Aarhus University such that the people with knolaged of the protocol is in the same building was the main factors for using $DUPLO$. The fact that $DUPLO$ supported the possibility of single and destinct wire openings to a desired party helped the decision. 

\bigskip

In the next section I will introduce the different fundtions in the framework and what they achive.

%%%%%%%%%%%%%%%%%%%%% DUPLO FRAMEWORK %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The Framework}
\label{sec:framework}
The $DUPLO$ 2PC framework was chosen to use during the experiemnt of implemeting a poker game. $DUPLO$ consist of two parties, a $Constructor$ and an $Evaluator$ with different roles during the protocol. The $Constructor$ generates the garbled circuits and sends to them to the $Evaluator$. The $Evaluator$ verifies a number of these circuits. If these pass the $Evaluator$ trust that the remaining circuits are valid. Then these remaining circuits is used during evaluation.

The overall construction of the framework consists of different functions to call to allow for the right communication between the two partis. It is specified in wich order thes function should be called to ensure that the right information are at the parties at the right time. At the same time the spiltup of the functions allow for local computations to be done between these framework calls.

To run the protocol and use the famework a $Constructor$ and an $Evaluator$ is created. First of all they read the circuitfile specifying the functionality decired. In our case it is the shuffle algorithm which is introduced in chapter \ref{ch:shuffle}.

Once these are created they run the framework function calls in parrallel. First the two parties connect to each other via the $Connect$ call. In this case it is the $Constructor$ hosting the servise and then the $Evaluator$ connects to this. When they are connected they each make a call to the $Setup$ function to initialize the communication protocol which is the $XOR$-homomorphic commitment protocol. After this they start the preprocess phase of the componets in the circuit by running the $PreprocessComponentType$ function call. Which generates a garbles representation of the shuffle algorithm.

Then the $PrepareComponents$ function is called to produce input and output authentication such that the inputs and outputs can be transfered securly between the two parties.

After this the composed $Circuit$ is constructed by calling the $Build$ function. This constructs the complete circuit which is to be evaluated later by the call to $Evaluate$. This ensures that the function componets specified by the composed circuit file is soldered together in the right way. Such that the ouput wires from one subfunction is feeded to the right input wire on another subfunction. This is also done using the $XOR$-homomorphic commitments. When the next call is made to $Evaluate$ the input to the circuit is given and the circuit is evaluated on this. Such that a garbled output is generated. When this is done a call to $DecodeKeys$ can be made and the output of the circuit can be learned.

\bigskip

The evaluation of circuits in the $DUPLO$ protocol allows for openings of outwires to both parties or only one. This will allow us to only reveal some cards to one player and other cards to the other. The split up of $Evaluate$ and $DecodeKey$ functions allows for opening of output wires in different rounds which helps us achive good round complexity when doing our implementation.


\section{Security}
\label{sec:secutity}
In this section I will introduce the security of the protocol to show that plyers playeing a game of poker with an implementation using the $DUPLO$ framework will have $oblivioness$, implying that the oponent can not learn more that supposed to. The players will also be ensured $correctnes$ of the protocol, meaning that if garbled evaluation is done it gives the right output. $DUPLO$ also ensures $authenticity$ because it is not possible for a player to doing evaluation of the functionality on other input the the party garbling the circuit.

\bigskip

The proff of security for the protocol is done using the Universal Composision(UC) framework. This is an easy digested abstract protocol proof technuiqe which allows for sequential predefined interaction between parties using actions and reactions. It has a modular approche to functionality proofs, when one functionality has been proved it can be used as a steppingstone for the next proof. In $DUPLO$ they use the hybrid model with ideal functionalities $\mathcal{F}_{HCOM}$ and $\mathcal{F}_{OT}$. Where the $\mathcal{F}_{HCOM}$ functionality is for the $XOR$-homomorphic commitment scheme used by the protocol, and $\mathcal{F}_{OT}$ for the one out of two oblivious transfer. These functions are then used to prove $correctness$, $obliviousness$ and $authenticity$ of the protocol. 

\todo{Protocol overall security proof appendix a}
In the section on protocol details in \citeA{duplo} appendix $A$ they describe and analyse the protocol. Here structioring the main protocol and going into details on how $correctness$, $obliviousness$ and $authenticity$ is guaranteed therough the different protocol function calls. The proof end up beeing rather complex as the main structur consist of $8$ subfunctions, which each is a combination of futher subcircuits. All of these functions are guaranteed to satisfy the properties. During the analysis of these functions they end up with lemmas proving correctness of; soldering and evaluation of subcircuits. They end up with leammas proving robustness of; the key authenticator bucketes, evaluation of key authenticators, input of constructor, input of evaluator, evaluation of subcircuits and output of evaluator. This colminate in the theorem proving robustness of the protocol, showing that if the $constructor$ is corrupt and the $evaluator$ is honest and the protocol does not abort, then the protocol compleets holding the before mentioned property, except with negligible propability. As known when using MPC protocols where half or more of the parties are corrupt we can not guarantee termination.

\todo{Protocol security analysis appendix b}
In appendix $B$ they prove the fact that the protocol is secure agains a corrupt $constructor$ or $evaluator$. Since it is a 2PC we may assume that one of the parties is honest as the partis trust in them selfs. When proving in the UC framework it is worth to remember that a poly-time simulator $\mathcal{S}$ should be presented. For the case of a corrupted $constructor$, $\mathbf{G}$ for generator, and a honest $Evaluator$, $\mathbf{E}$. $\mathcal{S}$ plays the role of $\mathbf{E}$ in the protocol, but is not given acces to the inputs of $\mathbf{E}$, $x_{\mathbf{E}}$. Instead $\mathcal{S}$ has access to an oracle $\mathcal{O}_{x_{\mathbf{E}}}(\cdot)$ containing $x_{\mathbf{E}}$. $\mathcal{S}$ might contact $\mathcal{O_{x_{\mathbf{E}}}}$ giving input $x_{\mathbf{G}}$ and in return learn $y_{\mathbf{G}}$ as if the evaluation of the functionality was done with $x_{\mathbf{E}}$ and $x_{\mathbf{G}}$ as input.

To show that the protocol is secure in this setting we need to show that a $constructor$ running the protocol can not distinguige between talking to $\mathbf{E}$ or $\mathcal{S}$. ???  

\todo{What is needed of the protocol, active security, single wire opening, duplo}

\todo{Preprocessing of duplo, serversetting interresting to study in stead of application}

%%%%%%%%%%%%%%%%%%% Frigate %%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Frigate the $DUPLO$ Circuit Compiler}
In this section I will introduce how the circuit compiler workes. Which problems I encountered and how some of them were fixed. 

First of all the compiler needs to be installed which require some special versions of some libarys which are not the latest. This requires that some specific setup for the compiler is done. But folowing the instructions in the installation guide and some internet seach made the compiler run.

Then when a program has been written in the $wir$ format specified by the documentation one compiles it to th $DUPLO$-format using the following command:

\begin{center}
\begin{verbatim}
./built/release/Frigate path/to/file.wir -dp
\end{verbatim}
\end{center}

This generates some different files where the one with the extention $.wir.GC\_duplo$ is the one that $DOPLO$ can use as input.

\bigskip

The $DOPLO$ framework has a function that allowes for evaluation of these inputfiles. This gives the posibility to specify the inputs from the two parties and get the result. This possibilty allowed me to study the implementations of the algorithms to see if thay did as I expected. First I tried to implement the $Fisher\text{-}Yates$ algorithm and as described earlier this revealed some problems. Since I did not have earlier experience working with the $Frigate$ compiler I was not sure if the problem was in my implementation or in the compiler. At first the focus was on my implementation but it was later discovered that it was the version of the $Frigate$ compiler used to generate $DUPLO$-circuits. First I expected it was in my implemetation. Why I starte to break the implementaion down into smaller modules that could be tested. So I created a framework that allowed me to test the different modules one by one. After this it was clear that something were off when using the modulo reduction. After different attempts to get it to work without any luck the focus shifted from being on the implemetaion to be on the compiler. After breaking the implementation down and testing only the modulo operator $\%$ which is in the documentation for the compiler it could not be the case that I had made any error. Therefor I started to look into the compiler. Since the compiler I used was an extention of an existing one the idea was that a bug could have been introduced when adding the new fatures. Therefor the old version of $Frigate$ was installed to test if this implemetation had the same bug. The problem was that the old version did not support any circuit output format that $DUPLO$ could read. Since $DUPLO$ supports what is known as composed circuit format files and $bristol$ formatted circuit files. I wrote a parser that took the output from the old version of $Frigate$ and translated that to $bristol$ format. This gave me two versions of the same program that I could run against each other and compare their results. This showed that there was a difference in the results produced. When I looked deeper into the problem it came clear that not all gate types was implemeted an the modulo operator triggered one of these gates.

This resulted in a fix of the new version of the $Frigate$ compiler and a complete change in the representation format of the circuits. Now all gates in the $DUPLO$ circuit format has two input and one putput wire. The representation of gates chaged from a more human readable type like $XOR$ to a truth table frendly type like $0110$ for $XOR$. And now all $16$ gate types from the truth table figure are implemented. The representation of the two constant wires $\textbf{0}$ and $\textbf{1}$ is handled as special cases since all gates now has two input wires. For the case of $\textbf{0}$ it is handled as an $XOR$ gate with two input wires with the same value. For the case of $\textbf{1}$ it was handled as the $NXOR$ of two wires with the same input value.

In this way I have contributed to the $DUPLO$ project and helped secure a stronger research product.

On the other side the compiler has not been updated to support modulo with a deviser that is not the power of $2$. As mentioned earlier the small amount of reserch I did into that area when I noticed the problem seems to indicate that this is not trivilay fixed. Therefor this is leaft unfixed.


%%%%%%%%%%%%%%%%%%%% SHUFFLE ALGORITHMS %%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Shuffling Algorithms}
\label{ch:shuffle}
In this chapter I will introduce the different shuffling algorithms studied during this project. I will introduce the ideas behind each algorithm studied and what makes it special. I will introduce why these were chosen. I will explain how they were optimized to fit better to the specific needs for a poker game. Lastly I will compare the algorithms to see the different benefits, and based on this choose which algorithm to use in the implementation.

The permutation algorithms studied are with the purpose of shuffling card decks. It is important to chose an algorithm that ensures that the correct amount of permutations is reached.

The first algorithm studied is the Fisher-Yates algorithm introduced in \citeB{fisher_yates}. It may also be known as Knuth shuffle which was introduced to computer science by R. Durstenfeld in \citeA{durstenfeld} as algorithm 235. This algorithm uses an in place permutation approach and gives a perfect uniform random permutation. This algorithm is introduced in section \ref{sec:fisher-yates} and can be seen in pseudocode as algorithm \ref{alg:fisher_yates}.

The second algorithm proposed uses ideas from shuffling networks and \citeA{psi} as conditional swap combined with the well known $bubble\text{-}sort$ algorithm. The idea is simple and use conditional swaps gadgets which swaps two inputs based on some condition. This algorithm is introduced in section \ref{sec:con_swap} and can be seen in pseudocode as algorithm \ref{alg:con_swap}. This algorithm yields a perfect uniform permutation.

These shuffle algorithms is optimized to fit to the poker setting introduced in the section \ref{sec:poker} on poker in chapter \ref{ch:intro}. This is done such that it only shuffles the required cards and not the whole deck.

The implementations of these algorithms will be introduced in section \ref{sec:cir_imp} where the choises made will be discussed. At last in section \ref{sec:comp} a comparison of the algorithms is done. Here I chose which algorithm to use in the implemetation of the poker game and benchmark upon. In this section other type of shuffling networks called Bitonic shuffle network will be introduced and discussed shortly. No implementation of such a shuffle network was done.

\bigskip

In the next section the $Fisher\text{-}Yates$ algorithm will be studied, it can be found as algorithm \ref{alg:fisher_yates} in section \ref{sec:fisher-yates}.

%%%%%%%%%%%%%%%%%%%%%%% FISHER YATES %%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fisher-Yates}
\label{sec:fisher-yates}

\begin{algorithm}
\caption{\textbf{\textit{Fisher-Yates}} \newline
    $deck$ is initialized to hold $n$ cards $c$. \newline
    $seeds$ is initialized to hold $n$ random $r$ values where $r_i\in[i,n]$ for $i\in [1,n]$.
}
\label{alg:fisher_yates}

\begin{algorithmic}[1]
\Function{Swap}{card1, card2}
\State $tmp = card1$
\State $card1 = card2$
\State $card2 = tmp$
\EndFunction
\State
\Function{Shuffle}{deck, seeds}
\For{i=1 to n}
\State $r = seeds[i]$
\State \Call{Swap}{$deck[i],~deck[r]$}
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

The $Fisher\text{-}Yates$ algorithm can be seen in algorithm \ref{alg:fisher_yates}. It is a well known in place permutation algorithm that given two arrays as input; one that contains the values that should be shuffled, here denoted $deck$, and another holding the values specifing how the first array should be shuffled, here denoted $seeds$. These swap values from $seeds$ indicate where each of the original values should go in the swap. When the algorithm runs through the first array which is supposed to be permuted it swaps the value at an given index whit the value specified by the swap value of the second array. Think of the input to be shuffled as a card deck then you take the top card of the deck and swap it with another card at a position defined by the swap value.

This implies that the algorithm takes two inputs of the same size where the one is holding the values to be permuted, $deck$ with $n$ vlause $card_i$, for $i=0,\dots,n$. The other holding the values for which the different $card_i$ in the $deck$ is to be swapped, $seeds$ with $n$ values $seed_i$. If the swap values $seed_i$ from the $seeds$ are not given in the correct interval the probability for the different permutations is not equally likely. Therefore it is important that the $seed_i$ values are chosen accordingly to the algorithm. The algorithm states that $seed_i$ is chosen from an interval starting with its own index $i$ to the size $n$ of the $deck$. This gives exactly the number of permutations required as $card_1$ has exactly $n$ possible places to go. $card_2$ has $n-1$ possible places and so forth until the algorithm reaches $card_n$ which has no other place to go. Since $seed_i\in[i,n]$ we have $n!$ because $i$ runs from $1$ to $n$ which should be the case as described in section \ref{sec:poker}.

If the $seed_i$ values contained in $seeds$ is not chosen for the right interval but instead all is chosen from $1$ to $n$ we would end up having a skew on the probability of the different permutations. As $card_i$ in this case has $n$ possible places to go, this yields $n^n$ distinct permutations. This introduces an error into the algorithm as there should only be $n!$ and as $n^n$ is not divisible by $n!$ for $n>2$. This result in a non uniform probability of the different permutations. The same is the problem if $seed_i$ is not chosen from $[i,n]$ but instead $]i,n]$ such that the own index is not in the interval. By introducing this error to the algorithm the empty shuffle is not possible. In other words it is not possible to get the same output as the input. Which does not give the desired uniform distribution of permutations.

\bigskip

In case of the poker game we need $52!$ permutations. If all $seed_i$ is chosen from $[i;52]$ we would get $52^{52}$ possible permutations. As described $52^{52}$ is not divisible by $52!$ since $52>2$. If $seed_i$ instead is shosen from $]i;52]$ we get $(52-1)!$ permutations which is neither devisible by $52!$.

\bigskip

As described in section \ref{sec:poker} no more then a permutation on the first 20 cards is needed. Which means that we only need the $\frac{52!}{32!}$ specific permutations out of the total of $52!$ different permutations. Doing a $m$ out of $n$ permutation using the $Fisher\text{-}Yates$ algorithm is straight forward. Instead of running through $n$ swaps indicated by the size of $seeds$ it is enough to run through $m$ swaps. In out case resulting in the input $seeds$ only need to have size $20$ and therefore the for-loop seen in algorithm \ref{alg:fisher_yates} in the shuffle function needs to have fewer iterations. Those giving us a full permutation on the first $m$ indexes of $deck$.

\bigskip

\begin{figure}
\centering
\scalebox{1.5}{\input{figurs/fisher-yates}}
\caption{Fisher-Yates algorithm in action: In this figure a 9 out of 52 shuffle has been completed to ilustrade how the algorithm works. First 1 is swpaed with 1. Then 2 is swaped with 51. 3 with 14. 4 with 20 and so on until the first 9 numbers has completed a full permutation. Resulting in 1, 51, 14, 20, 10, 37, 9, 33, 6.}
\label{fig:fisher_yates}
\end{figure}

In figure \ref{fig:fisher_yates} it is possible to see the $Fisher\text{-}Yates$ shuffle in action. Here the first $9$ cards of a sorted deck is shuffled according to the giving seed. Running the algorithm on these inputs give the $9$ first cards $1,~52,~14,~20,~10,~37,~9,~33,~6$ as output. It is interesting to notice that $37$ in the seed twice. Since the algorithm permute the imput $deck$ the value $37$ will not be in the output twice. We see that $6$ is swapped in the second time the seed $37$ is used. This is because the first time $6$ and $37$ was swapped. This illustate that it is possible for a $card$ to be swapped multible times.


%%%%%%%%%%%%%%%%%%%%% SHUFFLE NETWOKS %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shuffle Networks}
Shuffling networks or permutation networks has a lot of resemblance to sorting networks. The idea behind this type of networks is that they consist of a number of input wires and equally many output wires. These wires go through the entire network. On these wires a swap gate is plased. This gate is constructed such that if a condition is satisfied the input on the two wires are swapped. By placing these swap gates correctly on the input wires it is possible to get a complete uniform random permutation of the input on the output wires.

Applying such a shuffle network in the setting of a poker game is simple. The input to the shuffle algorithm is the $deck$ that we want to shuffle and the output is the shuffled $deck$. The more interesting part is how to place the swap gates to ensure that the right number of possible permutations is satisfied. There are many different shuffle algorithms that can be implemented using shuffle networks. The one I have looked into and implemeted builds on ideas from \citeA{psi} where they introduces the conditional swap gate. The algorithm is a combination of the well known $bubble\text{-}sort$ algorithm and the conditional swap.

\bigskip

In the next section I will introduce the conditional swap algorithm, which can be seen as algorithm \ref{alg:con_swap}.

\bigskip

\paragraph{Conditional Swap:}
\label{sec:con_swap}

\begin{algorithm}
\caption{\textbf{\textit{Conditional swap}} \newline
    $deck$ is initialized to hold $n$ cards $c$. \newline
    $seeds$ is initialized to hold $\frac{n^2}{2}$ random $bit$ values where $bit_i\in[0,1]$ for $i\in [1,\frac{n^2}{2}]$.
}
\label{alg:con_swap}

\begin{algorithmic}[1]
\Function{ConditionalSwap}{bit, card1, card2}
\If{bit equal 1}
\State $tmp = card1$
\State $card1 = card2$
\State $card2 = tmp$
\EndIf
\EndFunction
\State
\Function{Shuffle}{deck, seeds}
\State $index = 0$
\For{i=1 to n}
\For{j=n-1 to i}
\State $index = index + 1$
\State $bit = seeds[index]$
\State \Call{ConditionalSwap}{$bit,~deck[j],~deck[j + 1]$}
\EndFor
\EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}


The conditional swap algorithm takes two inputs; the first input is an array, denoted $deck$ of $n$ cards $card_i$ for $i=1,\dots,n$, and the second an array $seeds$ of size $l=\frac{n^2}{2}$ bits $b_j$ where $j=1,\dots, l$. The algorithm creates $n-1$ layers of conditional swap gates. The first layer contains $n-1$ conditional swap gates. The second $n-2$ and so on until the las layer consisting of one gate. Each layer is constructed such that a swap gate is placed on two adjacent input wires. Each of these gates overlap with one of the inputwires at the adjacent swap gate. This is illustarated in figure \ref{fig:con_swap}. The layers are stacked in such a way that the first input wire is only represented in the first layer. Thereby is the first value on the first output wires determined by the first layer of swap gates. Resulting in the first input $card_1$ has $n$ places to go. The second layer determines which output $card_2$ will have and so on. Continuing this way until reaching the last layer where the two last outputs $card_{n-1}$ and $card_n$ will be determined. This gives us a shuffle algorithm with a perfect shuffle and $n!$ different permutations as decired.

If each layer of the swap gates are not decreasing by one on the amount of swap gates this algorithm suffers the problem of producing $n^n$ permutations. Which is not devisible by the decired $n!$ permutations. This resulting in a skew of the probability on the different permutations such that the propability of each permutation is no longer uniform.

\bigskip

Again some optimization can be done to the algorithm since we only need a $m$ out of $n$ permutation. This can be done by letting the outer loop of algorithm \ref{alg:con_swap} run for $m$ iterations instead of $n$. This yields $n$ possible values for $card_1$, $n-1$ possible values for $card_2$ and so one until $n-m$ values for $card_{n-m}$. This is exactly the amount of permutation we require for our optimized algorithm as this gives us $\frac{n!}{(n-m)!}$. Which is enough for our poker implementation as described in section \ref{sec:poker}

\bigskip

\begin{figure}
\centering
\scalebox{1.5}{\input{figurs/con_swap_fig}}
\caption{Conditional swap algorithm in action: In this figure a 9 out of 52 shuffle has been completed to ilustrade how the algorithm works. Each bit in the $seeds$ indicate if a gate should be swapped. Since the size of $seeds$ is so big I have tried to ilustrate which wire each value is located at before moved in a layer resulting in 1, 51, 14, 20, 10, 37, 9, 33, 6.}
\label{fig:con_swap}
\end{figure}

In figure \ref{fig:con_swap} a run of algorithm \ref{alg:con_swap} can be seen Here a $9$ out of $52$ variant is used. It can be seen that the inputs $deck$ is soreted and holds the values to be shuffled and $seeds$ which are binary and indicates if two values should be swaped. The first $52$ bits of the $seeds$ decides if the first $card$ values should be shuffled. Which is not the case in this run. Then the next $51$ bist from $seeds$ indicate that $51$ should be swapped all the way accross to the wire repecenting the second out card. This implies that all cards $51$ passed on its way will now be on the right adjacent wire to where it was prior to the swap. That is why the third output $card$ with value $14$ starts at wire index $15$ and output wire four with value $20$ starts at wire index 21. So the algorithm continiues until it outputs the first $9$ cards shuffled as $1,~51,~14,~20,~10,~37,~9,~33,~6$.


%%%%%%%%%%%%%%%%% CIRCUIT IMPLEMENTATION %%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation}
\label{sec:cir_imp}

\todo{Describe the implementation of the algorithms}
\todo{Describe problems}
\todo{Describe solutions}
\todo{Describe gadgets of the two shuffle protocols}

Because the $DUPLO$ protocol was chosen as the MPC protocol to use in the implementation the first hurdel was to make the circuits that should handle the shuffling of cards. Since circuits become rather complex when trying to implement functions it was important to have a compiler that could translate the algorithms into the desired circuit representation. Luckly there was a compiler for generating $DUPLO$-circuits that could be used. Therefor before staring to implemt the shuffle algorithms I read up on the documentation for the compiler\footnote{Which can be found at github: \url{https://github.com/AarhusCrypto/DUPLO/tree/master/frigate}}. The documentation is from the first version of the $Frigate$ compiler which was extended to suit the $DUPLO$ format. The documentation was not well specified and it was a long time since I last had worked with circuits in such a way. This resulted in some hard earned experience through trial and error on small exapmles.

The most important and different things to take into account here is the possibility of wirre acces and only one level functions. First of all it is possible to specify which and how many wires should represent a value like $y=x\{index:size\}$. This is the way bit inputs is translated into higher level representations. When it comes to functions there are some restrictions. First of all only one level of functions is allowed. Second of all only assignments in the main method is allowed through function calls. Otherwise the programing language used resembles $C$.

\bigskip

In the implementation of the two shuffle algorithms there are five different functions used. For the $Conditional~swap$ algorithm the first function used is the $xorSeed$ which handles the $XOR$ of the $seeds$ recieved from the two parties. Which is straightforward. The next function used is the $initDeck$ function. This functions inicilises the sorted deck wich is to be shuffled. This is done by a for-loop inserting the right values on the right wires. Here $6$ bits is used for the representation of cards. It is importand to notice that the variable holding the start position of every card needs its own representation with at least $6$ bits to hold the correct value. If only $6$ bits were used only vires up to opsition $63$ could be assigned t value. Therefor $9$ bit is used for this variable. The $9$ bits comes from the fact that $\lceil \log_2(52\cdot 6)\rceil=9$ bits. The last function used in the $Conditional~swap$ algorithm is the $shuffleDeck$ function. This is the function handling the actual shuffling. This is implemented using two for-loops one for the layers of the network and another for the swap gates in each layer.

\bigskip

In the case for the $Fisher\text{-}Yates$ the things stack up a bit differently. The first function in this case is the $correctSeed$ function which takes the $seeds$ from the two parties and correct them as descussed earlier. First a card representation of $6$ bits is added from each of the parties. This can not be represented in $6$ bits therefor a bigger representation is used. The idea is that after the addition a modulo reduction will be use to ensure that the new seed value is inside the right intervall. But because the modulo reduction implemented in $Frigate$ only supports a divisor of power of $2$ modulo can not be used. Because the seed values calculated uses devisor different from these. I used some time to figure out that this was only supported since it is not statet anyware in the documentation. After experiencing this I tried to find some articles on how to implement a circuit for the modulo reduction. But during my search I found out that this is not a trivial task to do. Therefor another solution was chosen. Since the input $seeds$ to the functionality is assumed to be in the right intervalls the solution was to subtract the boundray of the interval if the sum exeeded this. This was done by introducing an $if$ statment. It is nothworthy to mention that all values have had an unsigned representation until now. Since the comparison of to values is needed a signed representation is introduced since the documentation stats that the comparison of two values only works on signed representations. This implemetations now ensures that the randomness used for the $shuffleDeck$ function has the right form. But only if the original inputs are inside the right intervalls.

The second function is the same as in the case for the $Conditional~swap$ algorithm which is the $initDeck$ function. The last function called is the $shuffleDeck$ function which is different from the one from the $Conditional~swap$ algorithm. This function constist of an outer-loop that runs through the cards. Because circuits are static as disscused earlier it is not possible to assign a wire value based on a variable input. Therefor layers of conditional swaps are generated. This is represented by the inner-loop. In this way a gadget for each is constructed such that the index specified by the outer-loop can be swapped with any other value in the rest of the card deck.


%%%%%%%%%%%%%%%%%%%%%%% COMPARISONS %%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

EVT SOMEWHERE HERE:
BEGIN
This algorithm requires much more randomness as input compared to the $Fisher\text{-}Yates$ algorithm. But this algorithm does not have the same problems of how the randomness should be chosen. This algorithm uses one bit of randomness at a time and therefore do not suffer from the problem of choosing randomness outside of the correct interval. Therefore this algorithm is more robust in terms of the input seeds. But if the inner for-loop is not running fewer and fewer rounds it will suffer the same problems as encountered by $Fisher\text{-}Yates$ because it will produce $n^n$ distinct possible sequences of swaps which is not compatible with the $n!$ possible permutations.
END

\section{Comparison}
\label{sec:comp}
\todo{describe circuit}
First of all it is important to understand that we cannot just plug the algorithm in to the MPC protocol. Since we use a MPC protocol that uses garbled circuits for the evaluation of the shuffle algorithm we need to provide a circuit that represent this algorithm. Therefor it is essential to understand how such circuits works and how to construct them. These circuits consist of different gates types. Special for the MPC protocol used here shuch type of circuit are all constructed of gates which has two input and one output wire. This results in 16 different gate types which can be used to construct a circuit. These 16 different gate types comes from the result of having two different values $0$ and $1$ for each of the wires. This gives $4$ different ways to combine the two values which results in $2^4$ different combinations. Of these 16 different gates are some of the well known $AND$, $OR$ and $XOR$. All the different gate types can be seen in figure.

\begin{table}
\label{truth_table}
\centering
\scalebox{.5}{
\begin{tabular}{c c || c c c c c c c c c c c c c c c c}
$l$ & $r$ & $0$ & NOR & $\neg x$ AND $y$ & $\neg x$ & $x$ AND $\neg y$ & $\neg y$ & XOR & NAND & AND & NXOR & $y$ & If $x$ Then $y$ & $x$ & If $y$ Then $x$ & OR & $1$    \\   
\hline
0 & 0 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1 & 0 & 1    \\
0 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 & 0 & 1 & 1    \\
1 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1    \\
1 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1
\end{tabular}
}
\caption{A table of the 16 different gate types that can be used in a circuit of the type used in duplo}
\end{table}

Since circuits is a static representation of a given algorithm it grow fast in size and become rather complex. Therefor to make the construction of the circuits for the shuffle algorithms easier I have used a compiler called $Frigate$\footnote{I used version 2 which is linked to in appendix \ref{appendix1}. This version is optimized to construct circuits for the duplo protocol.} to help with the circuit generation. The compiler takes a high-level program of a $C$ like structure and translates it to a circuit of the correct format for the MPC protocol chosen to use. This compiler gives the possibility to easy implement the shuffle algorithm and generate a complex circuit that represent the right algorithm.

\bigskip
In the next section I will try to compare the to different algorithms and their circuit representation. The first to look for in the two algorithms is the amount of loops. In the $Fisher\text{-}Yates$ algorithm there is one for-loop and which makes a direct swap resulting in $n$ total swaps. Where as in the $Conditional~swap$ algorithm we have both an outer for-loop and an inner for-loop. Which at creates $\frac{n^2}{2}$ calls to the conditional swap function. At first sight this seems to be many more calls to swap than for the $Fisher\text{-}Yates$ algorithm. But as mentioned earlier circuits are a static representation of an algorithm and therefore the two algorithms do not differ much from each other when comparing their circuit representation. First of all since circuits is a static representation of the algorithm the $Fisher\text{-}Yates$ algorithm can not do a swap based on an input to the algorithm unless all possible swaps are represented in the circuit. This resulting in the need for conditional swaps in the algorithm. Therefore in each of the rounds of the for-loop it should be possible for a value at a given index to go to all the indexes there or higher. This resulting in $n-1$ conditional swaps in the first round. $n-2$ conditional swaps in the second round and so forth. Since both algorithms now need to use conditional swaps they are easy to compare. We know that this gives exactly the same amount of conditional swaps for both algorithms, which is $(n-1)!$ if we do not take the optimizations into account. The biggest difference is how the two algorithms swap in the rounds of the outer for-loop. Here the $Fisher\text{-}Yates$ algorithm has conditional swaps from index $i$ to all the indexes $i'$ where $i<i'$. Where the $Conditional~swap$ algorithm has swaps from $j$ to $j'= j+1$ where $j$ is running from $i$ defined by the forloop to $n-1$.

Another different aspect of the algorithms is to compare the input. Both algorithms takes a $deck$ and $seeds$ as input. Where the $deck$ is the representation of the cards which is the same for both algorithms. But the input $seeds$ differs a lot. This is because of how the two algorithms handle the swaps. Therefore this is the interesting part to look at. First of all it is important to remember what the goal is for this thesis. It is to create a secure distributed poker game. Therefore we use a MPC protocol that help us overcome the security part. We can therefore expect that one of the players will try to cheat. As the protocol takes $seeds$ from both parties on how to shuffle the $deck$ we need to handle this in some way. The easy way is just to $XOR$ these $seeds$ together to get a new seed to use in the shuffle algorithm. This is completely fine in the $Conditional~swap$ algorithm since it uses one bit of randomness at a time for each swap gate. We know that the $XOR$ of to random bits yields a equally random bit. But for the $Fisher\text{-}Yates$ it makes the algorithm insecure since the $XOR$ of the two $seeds$ can result in a new seed that do not forfill the requirements to the inputs. This will give a bias that result in a higher probability of getting low cards. This is because the algorithm relies on the random $r$ values of the seed to be in given intervals. Therefore when $XOR$ the $seeds$ from the two parties it can not be guarantee that the random $r$ values for the shuffle is inside the correct interval. The easy solution to this will be to take the modulo reduction of $r$ to fit inside the desired interval. Here I will come with an example to show the problems by doing so. In our case we need to represent $52$ cards. These can be represented in base 2 using 6 bits since $\lceil{log_2(52)}\rceil=6$. But as we know $2^6=64$. This implies that we have $11$ possible values for our $r$ in the first round after the $seeds$ have been $XOR$'ed together. This result in the first $11$ values from $0$ to $10$ to have the probability $\frac{2}{64}$ while the last $31$ values from $11$ to $51$ have probability $\frac{1}{64}$ giving us a bias. 
Instead of using $XOR$ to construct the new $r$ values for the shuffle algorithm the $seeds$ will be added $6$ bits at a time. This resulting in a uniform propability on the $r$ values. Here it is important to notice that while $6$ bits is enough to hold the 52 card values it is not sufficient to hold the sum of such two values.

\bigskip

At last a short comment on other shuffle algorithmic possibilities. There do exist other types of sorting networks that could be used. In \citeA{psi} they also uses a algorithm known as the $Bitonic$ algorithm refering to the way the network is constructed. Such a network is constructed of what is known as $half-cleansers$ known from sorting networks. These $half-cleansers$ are constructed such that the input has one peak, $i_1\leq \dots \leq p \geq \dots \geq i_n$. Then the output is half sorted such that the highest values are in one of the two halfs. This creates a circuit of size $O(n\cdot log(n))$ which is better then what the $Conditional~swap$ and $Fisher\text{-}Yates$ algorithms can aquire since it creates a circuit of size $O(n^2)$. But as argued earlier the $Conditional~swap$ and $Fisher\text{-}Yates$ algorithms are easily optimized to the setting studied in this thesis.

\todo{Bitonic algorithm, optimization? can maybe be done by flipping such a sorting network and removing half cleansers}

As a result of this we get that for some card games it can be an idea to check if one algorithm can outperform another. In out case we need only $20$ out of $52$ cards. We now know that a $Bitonic$ algorithm would produce a smaller output but since the two algorithm studied here are easy to optimize such that they produce a relative small circuit. This implies that there will ba a cross over at some point where it is better to shuffle a complete deck than only parts of it even if only a part is needed. This could be in a setting when playing with more the two players for a game of poker.

\begin{table}
\label{circuit_gate_types}
\centering
\scalebox{.9}{
\begin{tabular}{l || r | r | r}
Circuit                      & $Fisher\text{-}Yates$ & $Conditiona~swap$ & Difference(\%) \\
\hline
Number of wires              & $835$                 & $4151$            & 397    \\
Number of gates              & $59790$               & $57364$           & 4   \\
Number of free $XOR$ gates   & $37433$               & $39001$           & 4   \\
Number of non-free gates     & $22357$               & $18363$           & 21
\end{tabular}
}
\caption{Compariason of the two implemented algorithms after compilation to $DUPLO$ circuits.}
\end{table}


In this section I will do a compariaon of the two compiled circuits. I chapter \ref{ch:shuffle} on the shuffle algorithms I compared the idea of the algorithms. Now after compiling them it is easier to argu how the two implemetations stack up against each other. In the table above where the circuits are compared on four different parameters. The first parmeter are the number of unique wires in the circuits. It is clearly that the $Fisher\text{-}Yates$ algorithm has less unique wires than the $Conditional~swap$ algorithm.

\todo{Does the number of unique wires effect the performance of the protocol?}

The second parameter mesured in the table is the total number of gates in the circuit. Here the numbers are farly similar. Doing a calculation shows that $Fisher\text{-}Yates$ has around $4\%$ more gates than $Conditional~swap$ which is not that big a differend. But when looking into the difference on the two last parameters. First we rememer that we are in a setting where $XOR$ gates are assumed for free. The parameters are the number of free $XOR$ and non-free. When the amount of these gates are mesured we see a bigger difference. When doing the calculations we see that $Fisher\text{-}Yates$ has $4\%$ less free gates than $Conditional~swap$ which is not much. We see the big difference when looking at the non-free gates. Here $Fisher\text{-}Yates$ has $21\%$ more non-free gates that what is the case for $Conditional~swap$. This is a big difference and in this case the effect of the difference is negativ on the performance of the protocol. Therefor even though the amount of randomness used in the algorithm is much smaller the overhed of ensuring that the seed is in the right intervall and the swap gadgets constructed for each card index result in a wors circuit for the $DUPLO$ protocol. Therefor the $Conditional~swap$ algorithm is used in the implemetation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Poker Implemetation}
\label{ch:implementation}
\input{implementation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{ch:conclusion}
\input{conclusion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{appendices}
\chapter{Codebase}
\input{appendix1}
\label{appendix1}
\end{appendices}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{chapter}{Primary Bibliography}
\bibliographystyleA{plain} 
\bibliographyA{references}
\addcontentsline{toc}{chapter}{Secondary Bibliography}
\bibliographystyleB{plain} 
\bibliographyB{references_sec} % remove this if you don't need secondary literature

%\bibliographystyle{plain}
%\bibliography{references}

\end{document}